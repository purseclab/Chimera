// Generated by P4_to_class.py.
//source: /home/intender/Workspace-remote/onos/pipelines/basic/src/main/resources/basic-ir.json
package edu.purdue.cs.pursec.ifuzzer.fuzz.mutation.packet.autogen;

import edu.purdue.cs.pursec.ifuzzer.fuzz.mutation.packet.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.*;

import p4testgen.P4Testgen;

public class BasicPktGenerator extends AutogenP4PktGenerator {
    enum ParserError {
        NoError,
        PacketTooShort,
        NoMatch,
        StackOutOfBounds,
        HeaderTooShort,
        ParserTimeout,
        ParserInvalidArgument,
    }

    private static Logger log = LoggerFactory.getLogger(BasicPktGenerator.class);
    private final Random rand = new Random();
    public List<String> stateList;
    Iterator<String> parserStateItr;
    private int pos;
    Map<BitVariable, Integer> lookaheadMap;

    BitVariable __v1model_version = new BitVariable(32, 20180101);

    class standard_metadata_t extends P4TypeStruct {
        BitVariable ingress_port = new BitVariable(9);
        BitVariable egress_spec = new BitVariable(9);
        BitVariable egress_port = new BitVariable(9);
        BitVariable instance_type = new BitVariable(32);
        BitVariable packet_length = new BitVariable(32);
        BitVariable enq_timestamp = new BitVariable(32);
        BitVariable enq_qdepth = new BitVariable(19);
        BitVariable deq_timedelta = new BitVariable(32);
        BitVariable deq_qdepth = new BitVariable(19);
        BitVariable ingress_global_timestamp = new BitVariable(48);
        BitVariable egress_global_timestamp = new BitVariable(48);
        BitVariable mcast_grp = new BitVariable(16);
        BitVariable egress_rid = new BitVariable(16);
        BitVariable checksum_error = new BitVariable(1);
        ParserError parser_error;
        BitVariable priority = new BitVariable(3);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            ingress_port.decode(bitStream);
            egress_spec.decode(bitStream);
            egress_port.decode(bitStream);
            instance_type.decode(bitStream);
            packet_length.decode(bitStream);
            enq_timestamp.decode(bitStream);
            enq_qdepth.decode(bitStream);
            deq_timedelta.decode(bitStream);
            deq_qdepth.decode(bitStream);
            ingress_global_timestamp.decode(bitStream);
            egress_global_timestamp.decode(bitStream);
            mcast_grp.decode(bitStream);
            egress_rid.decode(bitStream);
            checksum_error.decode(bitStream);
//            parser_error.decode(bitStream);
            priority.decode(bitStream);
        }
    }

    BitVariable port_t;

    BitVariable next_hop_id_t;

    BitVariable MeterColor;

    class packet_in_header_t extends P4TypeHeader {
        boolean isValid = false;
        BitVariable ingress_port = new BitVariable(9);
        BitVariable _padding = new BitVariable(7);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            if (isValid) {
                ingress_port.decode(bitStream);
                _padding.decode(bitStream);
            }
        }

        @Override
        public int getBitLength() {
            return 16;
        }
    }

    class packet_out_header_t extends P4TypeHeader {
        boolean isValid = false;
        BitVariable egress_port = new BitVariable(9);
        BitVariable _padding = new BitVariable(7);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            if (isValid) {
                egress_port.decode(bitStream);
                _padding.decode(bitStream);
            }
        }

        @Override
        public int getBitLength() {
            return 16;
        }
    }

    class ethernet_t extends P4TypeHeader {
        boolean isValid = false;
        BitVariable dst_addr = new BitVariable(48);
        BitVariable src_addr = new BitVariable(48);
        BitVariable ether_type = new BitVariable(16);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            if (isValid) {
                dst_addr.decode(bitStream);
                src_addr.decode(bitStream);
                ether_type.decode(bitStream);
            }
        }

        @Override
        public int getBitLength() {
            return 112;
        }
    }

    class ipv4_t extends P4TypeHeader {
        boolean isValid = false;
        BitVariable version = new BitVariable(4);
        BitVariable ihl = new BitVariable(4);
        BitVariable dscp = new BitVariable(6);
        BitVariable ecn = new BitVariable(2);
        BitVariable len = new BitVariable(16);
        BitVariable identification = new BitVariable(16);
        BitVariable flags = new BitVariable(3);
        BitVariable frag_offset = new BitVariable(13);
        BitVariable ttl = new BitVariable(8);
        BitVariable protocol = new BitVariable(8);
        BitVariable hdr_checksum = new BitVariable(16);
        BitVariable src_addr = new BitVariable(32);
        BitVariable dst_addr = new BitVariable(32);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            if (isValid) {
                version.decode(bitStream);
                ihl.decode(bitStream);
                dscp.decode(bitStream);
                ecn.decode(bitStream);
                len.decode(bitStream);
                identification.decode(bitStream);
                flags.decode(bitStream);
                frag_offset.decode(bitStream);
                ttl.decode(bitStream);
                protocol.decode(bitStream);
                hdr_checksum.decode(bitStream);
                src_addr.decode(bitStream);
                dst_addr.decode(bitStream);
            }
        }

        @Override
        public int getBitLength() {
            return 160;
        }
    }

    class tcp_t extends P4TypeHeader {
        boolean isValid = false;
        BitVariable src_port = new BitVariable(16);
        BitVariable dst_port = new BitVariable(16);
        BitVariable seq_no = new BitVariable(32);
        BitVariable ack_no = new BitVariable(32);
        BitVariable data_offset = new BitVariable(4);
        BitVariable res = new BitVariable(3);
        BitVariable ecn = new BitVariable(3);
        BitVariable ctrl = new BitVariable(6);
        BitVariable window = new BitVariable(16);
        BitVariable checksum = new BitVariable(16);
        BitVariable urgent_ptr = new BitVariable(16);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            if (isValid) {
                src_port.decode(bitStream);
                dst_port.decode(bitStream);
                seq_no.decode(bitStream);
                ack_no.decode(bitStream);
                data_offset.decode(bitStream);
                res.decode(bitStream);
                ecn.decode(bitStream);
                ctrl.decode(bitStream);
                window.decode(bitStream);
                checksum.decode(bitStream);
                urgent_ptr.decode(bitStream);
            }
        }

        @Override
        public int getBitLength() {
            return 160;
        }
    }

    class udp_t extends P4TypeHeader {
        boolean isValid = false;
        BitVariable src_port = new BitVariable(16);
        BitVariable dst_port = new BitVariable(16);
        BitVariable length_ = new BitVariable(16);
        BitVariable checksum = new BitVariable(16);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            if (isValid) {
                src_port.decode(bitStream);
                dst_port.decode(bitStream);
                length_.decode(bitStream);
                checksum.decode(bitStream);
            }
        }

        @Override
        public int getBitLength() {
            return 64;
        }
    }

    class headers_t extends P4TypeStruct {
        packet_out_header_t packet_out = new packet_out_header_t();
        packet_in_header_t packet_in = new packet_in_header_t();
        ethernet_t ethernet = new ethernet_t();
        ipv4_t ipv4 = new ipv4_t();
        tcp_t tcp = new tcp_t();
        udp_t udp = new udp_t();

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            packet_out.decode(bitStream);
            packet_in.decode(bitStream);
            ethernet.decode(bitStream);
            ipv4.decode(bitStream);
            tcp.decode(bitStream);
            udp.decode(bitStream);
        }
    }

    class local_metadata_t extends P4TypeStruct {
        BitVariable l4_src_port = new BitVariable(16);
        BitVariable l4_dst_port = new BitVariable(16);
        BitVariable next_hop_id = new BitVariable(16);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            l4_src_port.decode(bitStream);
            l4_dst_port.decode(bitStream);
            next_hop_id.decode(bitStream);
        }
    }

    headers_t hdr;
    local_metadata_t local_metadata;
    standard_metadata_t standard_metadata;


    private void start() {
        log.debug("START");
        stateList.add("START");
        List<String> internalStates = List.of(
                "parse_packet_out",
                "parse_ethernet");
        int caseNum;
        if (parserStateItr != null && parserStateItr.hasNext()) {
            caseNum = internalStates.indexOf(parserStateItr.next());
        } else {
            caseNum = rand.nextInt(2);
        }
        if (caseNum == 0) {
            standard_metadata.ingress_port.putValue(255);
            parse_packet_out();
        } else {
            parse_ethernet();
        }
    }


    private void parse_packet_out() {
        log.debug("PARSE_PACKET_OUT");
        stateList.add("PARSE_PACKET_OUT");
        //Extract hdr.packet_out
        pos += hdr.packet_out.getBitLength();
        hdr.packet_out.isValid = true;
        if (parserStateItr != null && parserStateItr.hasNext())
            parserStateItr.next();
        parse_ethernet();
    }


    private void parse_ethernet() {
        log.debug("PARSE_ETHERNET");
        stateList.add("PARSE_ETHERNET");
        //Extract hdr.ethernet
        pos += hdr.ethernet.getBitLength();
        hdr.ethernet.isValid = true;
        List<String> internalStates = List.of(
                "parse_ipv4",
                "accept");
        int caseNum;
        if (parserStateItr != null && parserStateItr.hasNext()) {
            caseNum = internalStates.indexOf(parserStateItr.next());
        } else {
            caseNum = rand.nextInt(2);
        }
        hdr.ethernet.ether_type.putRandom();
        if (caseNum == 0) {
            hdr.ethernet.ether_type.putValue(2048);
            parse_ipv4();
        } else {
            accept();
        }
    }


    private void parse_ipv4() {
        log.debug("PARSE_IPV4");
        stateList.add("PARSE_IPV4");
        //Extract hdr.ipv4
        pos += hdr.ipv4.getBitLength();
        hdr.ipv4.isValid = true;
        List<String> internalStates = List.of(
                "parse_tcp",
                "parse_udp",
                "accept");
        int caseNum;
        if (parserStateItr != null && parserStateItr.hasNext()) {
            caseNum = internalStates.indexOf(parserStateItr.next());
        } else {
            caseNum = rand.nextInt(3);
        }
        hdr.ipv4.protocol.putRandom();
        if (caseNum == 0) {
            hdr.ipv4.protocol.putValue(6);
            parse_tcp();
        } else if (caseNum == 1) {
            hdr.ipv4.protocol.putValue(17);
            parse_udp();
        } else {
            accept();
        }
    }


    private void parse_tcp() {
        log.debug("PARSE_TCP");
        stateList.add("PARSE_TCP");
        //Extract hdr.tcp
        pos += hdr.tcp.getBitLength();
        hdr.tcp.isValid = true;
        local_metadata.l4_src_port = hdr.tcp.src_port;
        local_metadata.l4_dst_port = hdr.tcp.dst_port;
        if (parserStateItr != null && parserStateItr.hasNext())
            parserStateItr.next();
        accept();
    }


    private void parse_udp() {
        log.debug("PARSE_UDP");
        stateList.add("PARSE_UDP");
        //Extract hdr.udp
        pos += hdr.udp.getBitLength();
        hdr.udp.isValid = true;
        local_metadata.l4_src_port = hdr.udp.src_port;
        local_metadata.l4_dst_port = hdr.udp.dst_port;
        if (parserStateItr != null && parserStateItr.hasNext())
            parserStateItr.next();
        accept();
    }


    private void accept() {
        log.debug("ACCEPT");
        stateList.add("ACCEPT");

    }


    private void reject() {
        log.debug("REJECT");
        stateList.add("REJECT");

    }

    @Override
    public Optional<Integer> getInputPort() {
        if (standard_metadata.ingress_port.isAllocated()) {
            return Optional.of(standard_metadata.ingress_port.toInt());
        }
        return Optional.empty();
    }

    @Override
    public PacketVariable parser_impl(P4Testgen.TestCase testCase) throws IOException {
        stateList = new ArrayList<>();
        parserStateItr = null;
        if (testCase.getParserStatesCount() > 0) {
            List<String> parserStateList = testCase.getParserStatesList().subList(0, rand.nextInt(testCase.getParserStatesCount() + 1));
            parserStateItr = parserStateList.iterator();
        }
        hdr = new headers_t();
        local_metadata = new local_metadata_t();
        standard_metadata = new standard_metadata_t();

        pos = 0;
        lookaheadMap = new HashMap<>();
        if (parserStateItr != null && parserStateItr.hasNext())
            parserStateItr.next();
        start();
        BitVarOutputStream bitStream = new BitVarOutputStream();
        hdr.decode(bitStream);
        PacketVariable packetVar = bitStream.toPacketVar();
        BitVarOutputStream tmpStream;
        return packetVar;

    }

    class tuple_0 extends P4TypeStruct {
        BitVariable f0 = new BitVariable(4);
        BitVariable f1 = new BitVariable(4);
        BitVariable f2 = new BitVariable(6);
        BitVariable f3 = new BitVariable(2);
        BitVariable f4 = new BitVariable(16);
        BitVariable f5 = new BitVariable(16);
        BitVariable f6 = new BitVariable(3);
        BitVariable f7 = new BitVariable(13);
        BitVariable f8 = new BitVariable(8);
        BitVariable f9 = new BitVariable(8);
        BitVariable f10 = new BitVariable(32);
        BitVariable f11 = new BitVariable(32);

        @Override
        public void decode(BitVarOutputStream bitStream) throws IOException {
            f0.decode(bitStream);
            f1.decode(bitStream);
            f2.decode(bitStream);
            f3.decode(bitStream);
            f4.decode(bitStream);
            f5.decode(bitStream);
            f6.decode(bitStream);
            f7.decode(bitStream);
            f8.decode(bitStream);
            f9.decode(bitStream);
            f10.decode(bitStream);
            f11.decode(bitStream);
        }
    }

}


