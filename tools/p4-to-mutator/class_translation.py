# Modified from https://github.com/gnmartins/assert-p4

import re
import uuid
from difflib import SequenceMatcher
# from helper import eprint

hasMarkToDrop = True
verbose = False
headers = []
lookaheadList = []
structFieldsHeaderTypes = {} #structField, structFieldType
structs = {} # structName, listOfFields
headerStackSize = {}
currentPacketAllocationPosition = 0
emitPosition = 0
typedef = {} #typedefName, typedefNode
actionIDs = {} #actionName, nodeID
tableIDs = {} #tableName, nodeID
declarationTypes = {} #instanceName, instanceType
declarationSizes = {} #instanceName, instanceSize
forwardDeclarations = []
package = ""
currentTable = ""
currentTableKeys = {} #keyName, (exact, lpm or ternary)
currentTableKeysOrdered = []
currentTableDefaultAction = ""
globalDeclarations = ""
assertionsCount = 0 #tracking id for klee_print_once
finalAssertions = """void assert_error(int id, char msg[]) {
\tklee_abort();
}

void end_assertions() {
"""
emitHeadersAssertions = []
extractHeadersAssertions = []
parserErrors = ["NoError", "PacketTooShort", "NoMatch", "StackOutOfBounds", "HeaderTooShort",
             "ParserTimeout", "ParserInvalidArgument"]

def verbose_print(*args, **kwargs):
    global verbose
    if verbose : print(*args, **kwargs)

# cleanup global variables for run() reusability in the same program...
def cleanup_variables(args):
    global headers
    headers = []
    global structFieldsHeaderTypes
    structFieldsHeaderTypes = {} #structField, structFieldType
    global structs
    structs = {} # structName, listOfFields
    global headerStackSize
    headerStackSize = {}
    global currentPacketAllocationPosition
    currentPacketAllocationPosition = 0
    global emitPosition
    emitPosition = 0
    global typedef
    typedef = {} #typedefName, typedefNode
    global actionIDs
    actionIDs = {} #actionName, nodeID
    global tableIDs
    tableIDs = {} #tableName, nodeID
    global declarationTypes
    declarationTypes = {} #instanceName, instanceType
    global forwardDeclarations
    forwardDeclarations = []
    global package
    package = ""
    global currentTable
    currentTable = ""
    global currentTableKeys
    currentTableKeys = {} #keyName, (exact, lpm or ternary)
    global currentTableKeysOrdered
    currentTableKeysOrdered = []
    global currentTableDefaultAction
    currentTableDefaultAction = ""
    global globalDeclarations
    globalDeclarations = "// Generated by P4_to_class.py.\n//source: " + args.p4_json + "\npackage edu.purdue.cs.pursec.ifuzzer.fuzz.mutation.packet.autogen;\n\nimport edu.purdue.cs.pursec.ifuzzer.fuzz.mutation.packet.api.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.*;\nimport p4testgen.P4Testgen;\n\n"
    global assertionsCount
    assertionsCount = 0 #tracking id for klee_print_once
    global finalAssertions

    global emitHeadersAssertions
    emitHeadersAssertions = []
    global extractHeadersAssertions
    extractHeadersAssertions = []

def remove_unecessary_extract_aux_vars(lines):
    returnString = ""
    global_vars = set()
    for line in lines:
        if "int extract_header_" in line:
            header = line.split(" ")[1][15:]
            if not (header in global_vars):
                global_vars.add(header)
                returnString += line + "\n"
        elif "[POST]" in line:
            header = line.split(" ")[0][22:]
            if header in global_vars:
                returnString += "\t" + line[7:] + "\n"
        else:
            returnString += line + "\n"
    return returnString

def post_processing(model_string):
    return remove_unecessary_extract_aux_vars(model_string.split("\n"))

def print_parser_error_enum():
    global parserErrors
    returnString = ""
    returnString += "enum ParserError {\n"
    for parserError in parserErrors:
        returnString += "\t" + parserError + ",\n"

    returnString += "}\n\n"
    return returnString


def run(node, args):
    global verbose
    verbose = args.verbose

    cleanup_variables(args)
    #returnString = "#define BITSLICE(x, a, b) ((x) >> (b)) & ((1 << ((a)-(b)+1)) - 1)\n"

    returnString = ""

    program = toJava(node)
    returnString += globalDeclarations
    '''
    for declaration in forwardDeclarations:
        returnString += "\nvoid " + declaration[0] + "(" + declaration[1] + ");"
    '''
    fileName = args.outfile
    returnString += "public class " + args.outfile + " extends AutogenP4PktGenerator {\n"
    returnString += print_parser_error_enum()
    returnString += "\tprivate static Logger log = LoggerFactory.getLogger(" + args.outfile + ".class);\n"
    returnString += "\tprivate final Random rand = new Random();\n"
    returnString += "\tpublic List<String> stateList;\n"
    returnString += "\tIterator<String> parserStateItr;\n"
    returnString += "\tprivate int pos;\n"
    returnString += "\tMap<BitVariable, Integer> lookaheadMap;\n"
    returnString += "\n" + program + "}\n\n"
    return returnString


def toJava(node):
    # test for annotations
    returnString = ""
    if hasattr(node, "annotations"):
        returnString += Annotations(node.annotations)
    if 'Vector' in node.Node_Type:
        for v in node.vec:
            #returnString += "<<" + str(v.Node_ID) + ">>"
            nodeString = toJava(v)
            if nodeString != "":
                returnString += nodeString + "\n"
    else:
        verbose_print(node.Node_Type, node.Node_ID)

        returnString += globals()[node.Node_Type](node) #calls corresponding type function according to node type
    return returnString

########### TYPE FUNCTIONS ###########

def P4Program(node):
    return toJava(node.objects)

def P4Control(node):
    return ""
    '''
    returnString = "//Control\n"
    actions = ""
    tables = ""
    for local in node.controlLocals.vec:
        if local.Node_Type == "Declaration_Variable" or local.Node_Type == "Declaration_Instance":
            nodeString = toJava(local)
            if nodeString != "":
                returnString += nodeString + "\n"
        elif local.Node_Type == "P4Action":
            actions += toJava(local) + "\n"
        elif local.Node_Type == "P4Table":
            tables += toJava(local) + "\n"
    returnString += "\nvoid " + node.name + "() {\n\t"
    for v in node.body.components.vec:
        returnString += toJava(v) + "\n\t"
    if len(node.body.components.vec) > 0:
        returnString = returnString[:-2]
    returnString += "\n}\n\n"
    returnString += actions
    returnString += tables
    return returnString
    '''

def Cmpl(node):
    return "~" + toJava(node.expr)

def BlockStatement(node):
    returnString = ""
    for v in node.components.vec:
        nodeString = toJava(v)
        if nodeString != "":
            returnString += "\t" + nodeString + "\n"
    return returnString

# precedence of operators require anoter set of parenthesis
def BAnd(node):
    return "(" + toJava(node.left) + " & " + toJava(node.right) + ")"

def BOr(node):
    return "(" + toJava(node.left) + " | " + toJava(node.right) + ")"

def BXor(node):
    #return "<BXor>" + str(node.Node_ID)
    return "(" + toJava(node.left) + " ^ " + toJava(node.right) + ")"

def Cast(node):
    return cast(node.expr, node.destType)

def Geq(node):
    return toJava(node.left) + " >= " +  toJava(node.right)

def Leq(node):
    return toJava(node.left) + " <= " +  toJava(node.right)

def LAnd(node):
    return toJava(node.left) + " && " + toJava(node.right)

def LOr(node):
    return toJava(node.left) + " || " + toJava(node.right)

def Slice(node):
    value = toJava(node.e0)
    m = toJava(node.e1)
    l = toJava(node.e2)
    return value + ".slice(" +  m + ", " + l + ")"

def Shl(node):
    return toJava(node.left) + " << " +  toJava(node.right)

def Shr(node):
    return toJava(node.left) + " >> " +  toJava(node.right)

def Mul(node):
    return str(toJava(node.left)) + " * " + str(toJava(node.right))

def ActionList(node):
    return actionListNoRules(node)

def ActionListElement(node):
    #return "<ActionListElement>" + str(node.Node_ID)
    return ""

def Add(node):
    return add(node)

def Sub(node):
    return sub(node)

def Annotation(node):
    #return "<Annotation>" + str(node.Node_ID)
    return ""

def Annotations(node):
    returnString = ""
    for annotation in node.annotations.vec:
        if annotation.name == "assert":
            # assert_string = annotation.expr.vec[0].value
            assert_string = annotation.body.vec[0].text
            assertionResults = assertion(assert_string, annotation.body.vec[0].Node_ID)
            returnString += assertionResults[0]
            #if assert_string[1] != "":
            #    message = assert_string[1] + "\\n"
            global finalAssertions
            global assertionsCount
            finalAssertions += "\tif (!({0}))\n\t\tassert_error({1}, \"Assertion error: {0}\");\n".format(assertionResults[1], assertionsCount)
            assertionsCount += 1
    return returnString

def assertion(assertionString, nodeID):
    returnString = ""
    logicalExpression = ""
    # errorMessage = ""
    global globalDeclarations
    if "!" == assertionString[0]:
        neg = assertion(assertionString[1:], nodeID)
        returnString += neg[0]
        logicalExpression = "!" + neg[1]
    elif "if(" == assertionString[:3]: #TODO: finish this
        ifExpression = assertionString[assertionString.find("(")+1:assertionString.rfind(")")]
        ifParameters = re.split(r',\s*(?![^()]*\))', ifExpression)
        left = assertion(ifParameters[0], nodeID)
        returnString += left[0]
        right = assertion(ifParameters[1], nodeID)
        returnString += right[0]
        logicalExpression = "!(" + left[1] + ") || (" + right[1] + ")"
    elif "&&" in assertionString:
        andParameters = assertionString.split(" && ")
        left = assertion(andParameters[0], nodeID)
        right = assertion(andParameters[1], nodeID)
        returnString += left[0]
        returnString += right[0]
        logicalExpression = "(" + left[1] + ") && (" + right[1] + ")"
    elif "==" in assertionString:
        equalityParameters = assertionString.split("==")
        left = equalityParameters[0]
        right = equalityParameters[1]
        globalVarName =  left.replace(".", "_")[:-1] + "_eq_" + right.replace(".", "_")[-1:] + "_" + str(nodeID)
        # global globalDeclarations
        globalDeclarations += "\n int " + globalVarName + ";\n"
        logicalExpression = globalVarName
        returnString += globalVarName + " = (" + left + " == " + right + ");\n\t"
    elif "<" in assertionString:
        equalityParameters = assertionString.split("<")
        left = equalityParameters[0]
        right = equalityParameters[1]
        globalVarName =  left.replace(".", "_")[:-1] + "_le_" + right.replace(".", "_")[-1:] + "_" + str(nodeID)
        # global globalDeclarations
        globalDeclarations += "\n int " + globalVarName + ";\n"
        logicalExpression = globalVarName
        returnString += globalVarName + " = (" + left + " < " + right + ");\n\t"
    elif "constant" in assertionString:
        constantVariable = assertionString[assertionString.find("(")+1:assertionString.rfind(")")]
        globalVarName = "constant_" + constantVariable.replace(".", "_") + "_" + str(nodeID)
        constantType = "uint64_t"#TODO: get proper field type
        # global globalDeclarations
        globalDeclarations += "\n" + constantType + " " + globalVarName + ";\n"
        logicalExpression =  globalVarName + " == " + constantVariable
        returnString += globalVarName + " = " + constantVariable + ";"
    elif "extract" in assertionString: #TODO: assign variable to true when extract field in model
        headerToExtract = assertionString[assertionString.find("(")+1:assertionString.rfind(")")].replace(".", "_")
        globalVarName = "extract_header_" + headerToExtract
        # global globalDeclarations
        globalDeclarations += "\nint " + globalVarName + " = 0;\n"
        logicalExpression =  globalVarName
    elif "emit" in assertionString:
        headerToEmit = assertionString[assertionString.find("(")+1:assertionString.rfind(")")].replace(".", "_")
        headerToEmitNoHeaderStack = headerToEmit.replace("[", "").replace("]", "")
        globalVarName = "emit_header_" + headerToEmitNoHeaderStack
        emitHeadersAssertions.append(headerToEmit)
        # global globalDeclarations
        globalDeclarations += "\nint " + globalVarName + " = 0;\n"
        logicalExpression = globalVarName
    elif "forward" in assertionString:
        logicalExpression = "assert_forward"
    elif "traverse" in assertionString:
        #traverseParameter = assertionString[assertionString.find("(")+1:assertionString.rfind(")")]
        globalVarName = "traverse_" + str(nodeID)
        # global globalDeclarations
        globalDeclarations += "int " + globalVarName + " = 0;\n"
        logicalExpression = globalVarName
        #if traverseParameter:
        #    #TODO: add globalVarName + " = 1;" to the parameter location
        #    pass
        #else:
        returnString += globalVarName + " = 1;"
    else:
        globalVarName = assertionString.replace(".", "_") + "_" + str(nodeID)
        # global globalDeclarations
        globalDeclarations += "\nint " + globalVarName + ";\n"
        returnString += globalVarName + " = (" + assertionString + " == 1);\n\t"
        logicalExpression = globalVarName
    return (returnString, logicalExpression)

def ArrayIndex(node):
    return toJava(node.left) + "[" + str(node.right.value) + "]"

def Argument(node):
    return toJava(node.expression)

def AssignmentStatement(node):
    global lookaheadList, declarationTypes

    if isExternal(node.right):
        symValue = toJava(node.left)
        return klee_make_symbolic(symValue)
    elif isLookahead(node.right):
        symValue = toJava(node.left)
        lookaheadList.append(symValue)
        return "\t" + symValue + " = new BitVariable(" + str(declarationSizes[symValue]) + ");\n\tlookaheadMap.put(" + symValue + ", pos);\n"
    return assign(node)

def BoolLiteral(node):
    if node.value == True:
        return "1"
    else:
        return "0"

def Constant(node):
    return str(node.value)

def Concat(node):
    # TODO: implement concat
    return concat(node)

def ConstructorCallExpression(node):
    #return "<ConstructorCallExpression>" + str(node.Node_ID)
    return ""

def Declaration_Constant(node):
    returnString = ""
    if node.type.Node_Type == "Type_Bits":
        returnString = "BitVariable " + node.name + " = new BitVariable(" + str(node.type.size) + ", " + toJava(node.initializer) + ");"
    elif node.type.Node_Type == "Type_Boolean":
        returnString = "boolean " + node.name + " ="
        returnString += " " + toJava(node.initializer) + ";"
    elif node.type.Node_Type == "Type_Name":
        returnString = node.type.path.name + " " + node.name + "="
        returnString += " " + toJava(node.initializer) + ";"
    else:
        return allocate(node)

    return returnString

def Declaration_Instance(node):
    returnString = ""
    if node.name == "main":
        if package == "V1Switch":
            parser = node.arguments.vec[0].expression.type.path.name if hasattr(node.arguments.vec[0].expression.type, "path") else node.arguments.vec[0].expression.type.name
            ingress = node.arguments.vec[2].expression.type.path.name if hasattr(node.arguments.vec[2].expression.type, "path") else node.arguments.vec[2].expression.type.name
            egress = node.arguments.vec[3].expression.type.path.name if hasattr(node.arguments.vec[3].expression.type, "path") else node.arguments.vec[3].expression.type.name
            deparser = node.arguments.vec[5].expression.type.path.name if hasattr(node.arguments.vec[5].expression.type, "path") else node.arguments.vec[5].expression.type.name
        elif package == "VSS":
            parser = node.arguments.vec[0].type.path.name if hasattr(node.arguments.vec[0].type, "path") else node.arguments.vec[0].type.name
            ingress = node.arguments.vec[1].type.path.name if hasattr(node.arguments.vec[1].type, "path") else node.arguments.vec[1].type.name
            deparser = node.arguments.vec[2].type.path.name if hasattr(node.arguments.vec[2].type, "path") else node.arguments.vec[2].type.name
    elif hasattr(node.type, "path"):
        declarationTypes[node.name] = node.type.path.name
    return returnString

def Declaration_Variable(node):
    global declarationSizes
    if node.type.Node_Type == "Type_Bits":
        declarationSizes[node.name] = node.type.size
        return "BitVariable " + node.name + ";"
    elif node.type.Node_Type == "Type_Boolean":
        return "boolean " + node.name + ";"
    elif node.type.Node_Type == "Type_Name":
        return node.type.path.name + " " + node.name + ";"
    return allocate(node)

def EmptyStatement(node):
    #return "<EmptyStatement>" + str(node.Node_ID)
    return ""

def Neq(node):
    return "(" + toJava(node.left) +  " != " + toJava(node.right) + ")"

def Equ(node):
    return "(" + toJava(node.left) +  " == " + toJava(node.right) + ")"

def ExpressionValue(node):
    return toJava(node.expression)

def ExitStatement(node):
    return ""

def Grt(node):
    return greater(node)

def IfStatement(node):
    return ifStatement(node)

def Key(node):
    returnString = "\t// keys: "
    for key in node.keyElements.vec:
        keyName = toJava(key.expression)
        matchType = toJava(key.matchType)
        currentTableKeys[keyName] = matchType
        currentTableKeysOrdered.append(keyName)
        returnString += keyName +  ":" + matchType + ", "
    return returnString[:-2]

def LNot(node):
    return "!" + toJava(node.expr)

def Member(node):
    if node.member != 'apply':
        if node.member == "last":
            nodeName = toJava(node.expr)
            return nodeName + "[" + nodeName + "_index - 1]"
        else:
            return toJava(node.expr) + "." + node.member
    else:
        nodeName = toJava(node.expr)
        if nodeName in tableIDs.keys():
            return nodeName + "_" + str(tableIDs[nodeName])
        elif nodeName in declarationTypes.keys():
            return declarationTypes[nodeName]
        else:
            return nodeName

def Method(node):
    global hasMarkToDrop
    if node.name == "mark_to_drop" and not hasMarkToDrop: #V1 specific
        hasMarkToDrop = True
        return mark_to_drop()
    else:
        return toJava(node.type)

def generatePushFront(node):
    returnString = ""
    count = toJava(node.arguments.vec[0])
    hdr = toJava(node.method)[:-11]
    returnString += "//push_front(" + count + ")\n"
    returnString += "\tint header_stack_size = sizeof(" + hdr + ")/sizeof(" + hdr + "[0]);\n\t"
    returnString += "int i;\n\t"
    returnString += "for (i = header_stack_size - 1; i >= 0; i -= 1) {\n\t\t"
    returnString += "if (i >= " + count + ") {\n\t\t\t"
    returnString += hdr + "[i] = " + hdr + "[i-" + count + "];\n\t\t"
    returnString += "} else {\n\t\t"
    returnString += hdr + "[i].isValid = false;\n\t}\n}\n\t"
    returnString += hdr + "_index = " + hdr + "_index + " + count + ";\n\t"
    returnString += "if (" + hdr + "_index > header_stack_size) " + hdr + "_index = header_stack_size;\n"
    return returnString

def MethodCallExpression(node):
    returnString = ""
    if hasattr(node.method, 'member') and node.method.member == "push_front":
        returnString += generatePushFront(node)
    elif hasattr(node.method, 'member') and node.method.member == "extract":
        returnString += extract(node)
    elif hasattr(node.method, 'member') and node.method.member == "emit":
        returnString += emit(node)
    elif hasattr(node.method, 'member') and node.method.member == "lookahead":
        returnString +=  "//Lookahead: " + toJava(node.method)
    elif hasattr(node.method, 'member') and node.method.member == "advance":
        returnString += advance(node)
     # execute meter, TODO: separate this into an 'extern methods' method
    elif hasattr(node.method, 'member') and node.method.member == "execute_meter":
        returnString += klee_make_symbolic(toJava(node.arguments.vec[1]))
    # read register, TODO: separate this into an 'extern methods' method
    elif hasattr(node.method, 'member') and node.method.member == "read":
        returnString += klee_make_symbolic(toJava(node.arguments.vec[0]))
    # write register, TODO: separate this into an 'extern methods' method
    elif hasattr(node.method, 'member') and node.method.member == "write":
        #ignore it
        pass
    # clone3, TODO: separate this into an 'extern methods' method
    elif hasattr(node.method, 'path') and node.method.path.name == "clone3":
         #ignore it
        pass
    # count, TODO: separate this into an 'extern methods' method
    elif hasattr(node.method, 'member') and node.method.member == "count":
         #ignore it
        pass
    # count, TODO: separate this into an 'extern methods' method
    elif hasattr(node.method, 'path') and node.method.path.name == "hash":
         returnString += klee_make_symbolic(toJava(node.arguments.vec[0]))
    # extern method: Name it as extern for later processing
    elif hasattr(node.method, 'expr') and node.method.expr.type.Node_Type == "Type_Extern":
        returnString +=  "//Extern: " + toJava(node.method)
    #verify method
    elif hasattr(node.method, 'path') and node.method.path.name == "verify":
        returnString += "if(!(" + toJava(node.arguments.vec[0]) + ")) {\n"
        returnString += "\t\tend_assertions();\n\t\texit(1);\n\t}\n"
     #SetValid method
    elif hasattr(node.method, 'member') and node.method.member == "setValid":
        returnString += toJava(node.method.expr) + ".isValid = true;"
     #SetInvalid method
    elif hasattr(node.method, 'member') and node.method.member == "setInvalid":
        returnString += toJava(node.method.expr) + ".isValid = false;"
    elif hasattr(node.method, 'path') and node.method.path.name == "random":
        field = toJava(node.arguments.vec[0])
        returnString += "//random\n\t"
        returnString += klee_make_symbolic(field)
        lowerBound = toJava(node.arguments.vec[1])
        upperBound = toJava(node.arguments.vec[2])
        returnString += "\n\tklee_assume(" + field + " > " + lowerBound + " && " + field + " < " + upperBound + ");"
    elif hasattr(node.method, 'path') and node.method.path.name == "digest":
        pass
    else:
        # Special treatment for "isValid" calls
        # isValid is modeled as an uint8_t instead of a function!
        if hasattr(node.method, 'member') and node.method.member == "isValid":
            returnString = toJava(node.method)
        else:
            returnString = toJava(node.method) + "();"

    return returnString

def MethodCallStatement(node):
    return toJava(node.methodCall)

def NameMapProperty(node):
    #return "<NameMapProperty>" + str(node.Node_ID)
    return ""

def P4Action(node):
    actionIDs[node.name] = node.Node_ID
    actionData = "action_run = " + str(node.Node_ID) + ";\n\t"
    parameters = ""
    for param in node.parameters.parameters.vec:
        if param.direction == "":
            if param.type.Node_Type == "Type_Bits":
                actionData += "BitVariable " + param.name + ";\n"
            else:
                actionData += toJava(param.type) + " " + param.name + ";\n"
            actionData += klee_make_symbolic(param.name)

    #Remove comma after last parameter
    if parameters != "":
        parameters = parameters[:-2]

    forwardDeclarations.append([node.name + "_" + str(node.Node_ID), parameters])

    actionName = node.name + "_" + str(node.Node_ID)
    return "// Action\nvoid " + actionName + "(" + parameters + ") {\n\t" + actionData + toJava(node.body) + "\n}\n\n"

def P4Table(node):
    #print("\nTable " + str(node.name))
    tableIDs[node.name] = node.Node_ID
    global currentTable
    currentTable = node.name
    forwardDeclarations.append([node.name + "_" + str(node.Node_ID), ""])
    tableBody = toJava(node.properties)
    global currentTableKeys
    currentTableKeys = {}
    global currentTableKeysOrdered
    currentTableKeysOrdered = []
    global currentTableDefaultAction
    currentTableDefaultAction = ""
    tableName = node.name + "_" + str(node.Node_ID)
    return "//Table\nvoid " + tableName + "() {\n" + tableBody + "\n}\n\n"

def ParameterList(node):
    returnString = ""
    for parameter in node.parameters.vec:
        returnString += allocate(parameter) + ",\n\t"
    return returnString

def Path(node):
    return node.name

def PathExpression(node):
    return toJava(node.path)

def Property(node):
    if node.name == "default_action":
        global currentTableDefaultAction
        currentTableDefaultAction = toJava(node.value)
        return "\t// default_action " + currentTableDefaultAction
    elif node.name == "size":
        return "\t// size " + toJava(node.value)
    elif node.name == "actions":
        return toJava(node.value)
    elif node.name == "key":
        return toJava(node.value)
    else:
        return ""

def SelectExpression(node):
    expressions = node.select.components.vec
    exp = []
    for expression in expressions:
        if expression.Node_Type == 'Slice':
            exp.append(Slice(expression))
        elif expression.Node_Type == 'Member':
            exp.append(toJava(expression.expr) + "." + expression.member)
        elif  expression.Node_Type == "MethodCallStatement":
            if expression.method.member == "isValid":
                exp.append(expression.method.expr.path.name + ".isValid")
        elif expression.Node_Type == 'Cast':
            exp.append(cast(expression.expr, expression.destType))
        elif expression.Node_Type == 'PathExpression':
             exp.append(toJava(expression.path))

    cases = node.selectCases.vec
    returnString = select(cases, exp)
    return returnString

def select(cases, exp):
    global lookaheadList
    returnString = ""

    caseNum = len(cases)

    if caseNum > 1:
        returnString += "List<String> internalStates = List.of(\n"
        for c, case in enumerate(cases):
            returnString += "\t\t\"" + case.state.path.name
            if c < caseNum - 1:
                returnString += "\",\n"
            else:
                returnString += "\");\n"

        returnString += "\tint caseNum;\n"
        returnString += "\tif (parserStateItr != null && parserStateItr.hasNext()) {\n"
        returnString += "\t\tcaseNum = internalStates.indexOf(parserStateItr.next());\n"
        returnString += "\t} else {\n"
        returnString += f"\t\tcaseNum = rand.nextInt({caseNum});\n"
        returnString += "\t}\n"

        for e in exp:
            expString = str(e)
            if ".slice(" in expString:
                expString = expString.partition(".slice(")[0]
            if expString not in lookaheadList:
                returnString += "\t" + expString + ".putRandom();\n"
    else:
        returnString += "if (parserStateItr != null && parserStateItr.hasNext())\n"
        returnString += "\t\tparserStateItr.next();\n"

    for c, case in enumerate(cases):
        fullExpression = ""
        for idx,e in enumerate(exp):
            #get apropriate case depending if select has multiple arguments or not
            if hasattr(case.keyset, 'components'):
                node = case.keyset.components.vec[idx]
            else:
                node = case.keyset

            if node.Node_Type == "Mask":
                a = toJava(node.left)
                b = toJava(node.right)
                #fullExpression += "((" + str(e) + " & " + b + ") == (" + a + " & " + b + ")) && "
                fullExpression += "\t\t" + str(e) + ".putValue(" + a + ", " + b + ");\n"
            elif node.Node_Type == 'Constant':
                fullExpression += "\t\t" + str(e) + ".putValue(" + str(node.value) + ");\n"
        if c == 0:
            returnString += "\t"
        if c < caseNum - 1:
            returnString += "if (caseNum == " + str(c) + ") {\n"
        else:
            returnString += "{\n"
        if fullExpression != "":
            returnString += fullExpression
        returnString += "\t\t" + case.state.path.name + "();\n\t} else "
    return returnString[:-6]

def StringLiteral(node):
    #return "<StringLiteral>" + str(node.Node_ID)
    return ""

def StructField(node):
    returnString = ""
    #warning: two headers defined in different structs
    #with the same name but different types would break this
    #future solution: discriminate by struct name
    if node.type.Node_Type == "Type_Name":
        structFieldsHeaderTypes[node.name] = node.type.path.name
        if node.type.path.name == "error":
            returnString += "\t" + "ParserError"
            returnString += " " + node.name + ";"
        else:
            returnString += "\t" + structFieldsHeaderTypes[node.name]
            returnString += " " + node.name + " = new "
            returnString += structFieldsHeaderTypes[node.name] + "();"
    elif node.type.Node_Type == "Type_Stack":
        structFieldsHeaderTypes[node.name] = node.type.elementType.path.name
        headerStackSize[node.name] = node.type.size.value
        returnString += "\tint " + node.name + "_index;\n"
        returnString += "\t" + structFieldsHeaderTypes[node.name] + " " + node.name + "[" + str(node.type.size.value) + "];"
    elif node.type.Node_Type == "Type_Bits":
        returnString += "\tBitVariable " + node.name + " = new BitVariable(" + str(node.type.size) + ");"
    elif node.type.Node_Type == "Type_Boolean":
        returnString += "\tBitVariable " + node.name + " = new BitVariable(1);"
    return returnString

def SwitchCase(node):
    return toJava(node.statement)

def SwitchStatement(node):
    returnString = ""
    if node.expression.member == "action_run":
        returnString += toJava(node.expression.expr) + "\n\t"
        defaultCase = None
        for case in node.cases.vec:
            if case.label.Node_Type != "DefaultExpression":
                returnString += "if(action_run == " + str(actionIDs[toJava(case.label)]) + ") {\n\t\t " + toJava(case) + "\n\t} else "
            else:
                defaultCase = toJava(case)
        if defaultCase:
            returnString += "{\n\t\t" + defaultCase + "\n\t}"
        else:
            returnString = returnString[:-6]

    else:
        switchCases = toJava(node.cases).replace("\n", ",")
        returnString = "Fork(InstructionBlock(), " + switchCases[:-1] + ")"
    return returnString

def TableProperties(node):
    return toJava(node.properties)

def TypeParameters(node):
    #return "<TypeParameters>" + str(node.Node_ID)
    return ""

def Type_Action(node):
    #return "<Type_Action>" + str(node.Node_ID)
    return ""

def Type_ActionEnum(node):
    #return "<Type_ActionEnum>" + str(node.Node_ID)
    return ""

def Type_Control(node):
    #return "<Type_Control>" + str(node.Node_ID)
    return ""

def Type_Method(node):
    #return "<Type_Method>" + str(node.Node_ID)
    return ""

def Type_Name(node):
    return toJava(node.path)

def TypeNameExpression(node):
    #return "<TypeNameExpression>" + str(node.Node_ID)
    return ""

def Type_Package(node):
    global package
    package = node.name
    return ""

def Type_Struct(node):
    structs[node.name] = node.fields.vec
    returnString = "class " + node.name + " extends P4TypeStruct {\n"
    returnString += toJava(node.fields)

    returnString += "\n\t@Override\n"
    returnString += "\tpublic void decode(BitVarOutputStream bitStream) throws IOException {\n"
    for field in node.fields.vec:
        returnString += "\t\t" + field.name + ".decode(bitStream);\n"
    returnString += "\t}\n}\n"
    return returnString

def Type_Table(node):
    return toJava(node.table)

def Type_Typedef(node):
    typedef[node.name] = node
    return "BitVariable " + node.name + ";\n"

def Type_Unknown(node):
    #return "<Type_Unknown>" + str(node.Node_ID)
    return ""

def Type_Error(node):
    #return "<Type_Error>" + str(node.Node_ID)
    return ""

def Type_Extern(node):
    return ""

def Type_Varbits(node):
    return ""

def Declaration_MatchKind(node):
    #return "<Declaration_MatchKind>" + str(node.Node_ID)
    return ""

def Type_Header(node):
    #not sure if it remains
    fields = []
    for field in node.fields.vec:
        fields.append(field)
    headerTuple = (node.name, fields)
    headers.append(headerTuple)
    ####
    returnString = "class " + node.name + " extends P4TypeHeader {\n\tboolean isValid = false;\n"
    totalSize = 0
    for field in node.fields.vec:
        if field.type.Node_Type == "Type_Bits":
            if field.name != "$valid$":
                returnString += "\tBitVariable " + field.name + " = new BitVariable(" + str(field.type.size) + ");\n"
                totalSize += field.type.size
        elif field.type.Node_Type == "Type_Boolean":
            if field.name != "$valid$":
                returnString += "\tBitVariable " + field.name + " = new BitVariable(1);\n"
                totalSize += 1
        else:
            typeName = toJava(field.type)
            #returnString += "\t" + typeName + " " + field.name + ": " + str(typedef[typeName].type.size) + ";\n"
            returnString += "\t" + typeName + " " + field.name + " = new " + typeName + "();\n"
    returnString += "\n\t@Override\n"
    returnString += "\tpublic void decode(BitVarOutputStream bitStream) throws IOException {\n"
    returnString += "\t\tif (isValid) {\n"
    for field in node.fields.vec:
        returnString += "\t\t\t" + field.name + ".decode(bitStream);\n"
    returnString += "\t\t}\n\t}\n\n"

    returnString += "\t@Override\n"
    returnString += "\tpublic int getBitLength() {\n"
    returnString += "\t\treturn " + str(totalSize) + ";\n"
    returnString += "\t}\n}\n"
    return returnString

def Type_HeaderUnion(node):
    #not sure if it remains
    fields = []
    for field in node.fields.vec:
        fields.append(field)
    headerTuple = (node.name, fields)
    headers.append(headerTuple)
    ####
    returnString = "class " + node.name + " {\n\tboolean isValid = false;\n"
    for field in node.fields.vec:
        if field.type.Node_Type == "Type_Bits":
            if field.name != "$valid$":
                returnString += "\tBitVariable " + field.name + " = new BitVariable(" + str(field.type.size) + ");\n"
        elif field.type.Node_Type == "Type_Boolean":
            if field.name != "$valid$":
                returnString += "\tBitVariable " + field.name + " = new BitVariable(1);\n"
        else:
            typeName = toJava(field.type)
            #returnString += "\t" + typeName + " " + field.name + ": " + str(typedef[typeName].type.size) + ";\n"
            returnString += "\t" + typeName + " " + field.name + " = new " + typeName + "();\n"
    returnString += "\n\tvoid decode(BitVarOutputStream bitStream) {\n"
    returnString += "\t\tif (isValid) {\n"
    for field in node.fields.vec:
        returnString += "\t\t\t" + field.name + ".decode(bitStream);\n"
    returnString += "\t\t}\n\t}\n}\n"
    return returnString

def P4Parser(node):
    global lookaheadList
    returnString = declareParameters(node)
    for l in node.parserLocals.vec:
        returnString += toJava(l) + "\n"
    returnString += "\n" + toJava(node.states)
    returnString += "@Override\n"
    returnString += "public PacketVariable parser_impl(P4Testgen.TestCase testCase) throws IOException {\n"
    returnString += "\tstateList = new ArrayList<>();\n"
    returnString += "\tparserStateItr = null;\n"
    returnString += "\tif (testCase.getParserStatesCount() > 0) {\n"
    returnString += "\t\tList<String> parserStateList = testCase.getParserStatesList().subList(0, rand.nextInt(testCase.getParserStatesCount() + 1));\n"
    returnString += "\t\tparserStateItr = parserStateList.iterator();\n"
    returnString += "\t}\n"

    returnString += defineParameters(node)
    returnString += "\tpos = 0;\n"
    returnString += "\tlookaheadMap = new HashMap<>();\n"
    for lookaheadVar in lookaheadList:
        returnString += "\t" + lookaheadVar + " = null;\n"

    returnString += "\tif (parserStateItr != null && parserStateItr.hasNext())\n"
    returnString += "\t\tparserStateItr.next();\n"
    returnString += "\tstart();\n"
    returnString += "\tBitVarOutputStream bitStream = new BitVarOutputStream();\n"
    returnString += DecodeParameters(node)

    returnString += "\tPacketVariable packetVar = bitStream.toPacketVar();\n"
    returnString += "\tBitVarOutputStream tmpStream;\n"

    # TODO: overwrite lookahead
    for lookaheadVar in lookaheadList:
        returnString += "\tif (" + lookaheadVar + " != null) {\n"
        returnString += "\t\ttmpStream = new BitVarOutputStream();\n"
        returnString += "\t\t" + lookaheadVar + ".decode(tmpStream);\n"
        returnString += "\t\tpacketVar.overwrite(tmpStream.toPacketVar(lookaheadMap.get(" + lookaheadVar + ")));\n"
        returnString += "\t}\n"
    returnString += "\treturn packetVar;\n"
    returnString += "\n}\n"
    return returnString

def Type_Enum(node):
    #return "<Type_Enum>" + str(node.Node_ID)
    return ""

def Type_Parser(node):
    #return "<Type_Parser>" + str(node.Node_ID)
    return ""

def dropPacketCode():
    returnString = "assert_forward = 0;\n\tend_assertions();\n"

    returnString += "\texit(0);"

    return returnString

def ParserState(node):
    components = ""
    for v in node.components.vec:
        components = components + "\t" + toJava(v) + "\n"
    expression = ""
    if hasattr(node, 'selectExpression'):
        expression += toJava(node.selectExpression)
        if "\n" not in expression:
            tmp = expression
            expression = "if (parserStateItr != null && parserStateItr.hasNext())\n"
            expression += "\t\tparserStateItr.next();\n"
            expression += "\t" + tmp
            expression += "();" #it is not a select, thus it is a direct parser state transition
    #if node.name == "reject":
    #expression += dropPacketCode()
    forwardDeclarations.append([node.name, ""])
    parser = "private void " + node.name + "() {\n"
    parser += "\tlog.debug(\"" + node.name.upper() + "\");\n"
    parser += "\tstateList.add(\"" + node.name.upper() + "\");\n"
    parser += components + "\t" + expression + "\n}\n\n"
    return parser

    # returnString = "val parserState_" + node.name + " = InstructionBlock(\n" + toJava(node.components) + ")\n"
    # return returnString

########### HELPER FUNCTIONS ###########

def convertCommandValue(arg):
    if ":" in arg:
        return str(int(arg.translate(None, ":"), 16))
    elif "." in arg: #Convert IP to uint_32
        octets = arg.split(".")
        binaryRep = ""
        for octet in octets:
            binaryRep += str('{0:08b}'.format(int(octet)))
        intRep = int(binaryRep, 2)
        return str(intRep)
    else:
        return arg

def getActionFullName(actionName):
    # actionName = actionName + "_"

    check_similarity = lambda a,b: SequenceMatcher(None, a, b).ratio()

    curr_action = "UNKNOWN_ACTION"
    similarity = 0.0

    # TODO: select the *correct* action (e.g. more than one action with the same name...)
    for action in actionIDs:
        if actionName in action:
            new_sim = check_similarity(actionName, action)
            if similarity < new_sim:
                curr_action = action
                similarity = new_sim

                if similarity > 0.9:
                    # print(actionName, curr_action, similarity, 'early return')
                    return action + "_" + str(actionIDs[action])

    # print(actionName, curr_action, similarity)

    if curr_action != "UNKNOWN_ACTION":
        return curr_action + "_" + str(actionIDs[curr_action])
    else:
        return "UNKNOWN_ACTION"

def actionListNoRules(node):
    returnString = "\tint symbol;\n" + klee_make_symbolic("symbol")
    returnString += "\tswitch(symbol) {\n"
    for idx,action in enumerate(node.actionList.vec):
        if idx == len(node.actionList.vec) - 1:
            returnString += "\t\tdefault: "
        else:
            returnString += "\t\tcase " + str(idx) + ": "
        if action.expression.Node_Type == "PathExpression":
            returnString += action.expression.path.name + "_" + str(actionIDs[action.expression.path.name]) + "(); "
        elif action.expression.Node_Type == "MethodCallExpression":
            returnString += action.expression.method.path.name + "_" + str(actionIDs[action.expression.method.path.name]) + "(); "
        else:
            returnString += "ERROR:UNKNOWN ACTION LIST TYPE"
        returnString += "break;\n"
    returnString += "\t}"
    return returnString

def defineParameters(node):
    returnString = ""
    for param in node.type.applyParams.parameters.vec:
        if (param.direction == "out" or param.direction == "inout") and param.type.Node_Type == 'Parameter':
            returnString += define_instance(param.type.name, param.type.path.name)
        if (param.direction == "out" or param.direction == "inout") and param.type.Node_Type == 'Type_Name':
            returnString += define_instance(param.name, param.type.path.name)
    return returnString + "\n"

def DecodeParameters(node):
    returnString = ""
    for param in node.type.applyParams.parameters.vec:
        if param.direction == "out" and param.type.Node_Type == 'Parameter':
            returnString += "\t" + param.type.name + ".decode(bitStream);"
        if param.direction == "out" and param.type.Node_Type == 'Type_Name':
            returnString += "\t" + param.name + ".decode(bitStream);"
    return returnString + "\n"

def SymbolizeParameters(node):
    returnString = ""
    for param in node.type.applyParams.parameters.vec:
        if (param.direction == "out" or param.direction == "inout") and param.type.Node_Type == 'Parameter':
            returnString += klee_make_symbolic(param.type.name)
        if (param.direction == "out" or param.direction == "inout") and param.type.Node_Type == 'Type_Name':
            returnString += klee_make_symbolic(param.name)
    return returnString + "\n"

def declareParameters(node):
    returnString = ""
    for param in node.type.applyParams.parameters.vec:
        if (param.direction == "out" or param.direction == "inout") and param.type.Node_Type == 'Parameter':
            returnString += declareParameter(param.type)
        if (param.direction == "out" or param.direction == "inout") and param.type.Node_Type == 'Type_Name':
            returnString += declareParameter(param)
    return returnString + "\n"

def declareParameter(param):
    return param.type.path.name + " " + param.name + ";\n"

def ifStatement(node):
    condition = ""
    returnString = ""
    condition = str(toJava(node.condition))
    returnString = "if(" + condition + ") {\n\t" + str(toJava(node.ifTrue)) + "\n}"
    if hasattr(node, "ifFalse"):
        returnString += " else {\n\t" + str(toJava(node.ifFalse)) + "\n}"
    return returnString


def greater(node):
    return str(toJava(node.left)) + " > " + str(toJava(node.right))

def add(node):
    return formatATNode(node.left) + " + " + formatATNode(node.right)

def sub(node):
    return formatATNode(node.left) + " - " + formatATNode(node.right)

def allocate(node):
    return "Allocate(\"" + node.name + "\")"

def assign(node):
    leftVarName = str(toJava(node.left))
    rightVarName = str(toJava(node.right))
    if "isValid" in leftVarName or "slice" in rightVarName or not rightVarName.isnumeric():
        return leftVarName + " = " + rightVarName + ";"
    return leftVarName + ".putValue(" + rightVarName + ");"

def concat(node):
    return formatATNode(node.left) + " ++ " + formatATNode(node.right)

def formatATNode(node):
    value = ""
    if node.Node_Type == 'Cast':
        value = formatATNode(node.expr)
    else:
        value = str(toJava(node))
    return value

def isExternal(node):
    # the variable could be external or inside an external variable
    return "//Extern" in toJava(node)

def isLookahead(node):
    # the variable could be external or inside an external variable
    return "//Lookahead" in toJava(node)

def getHeaderType(headerName):
    return structFieldsHeaderTypes[headerName]

def emit(node):
    returnString = ""
    hdrName = toJava(node.arguments.vec[0])
    returnString += "//Emit " + hdrName + "\n\t"
    headerName = ""
    if node.arguments.vec[0].Node_Type == "ArrayIndex":
        headerName = node.arguments.vec[0].left.member
    else:
        headerName = hdrName.split(".")[1]
    for emitAssertion in emitHeadersAssertions:
        if headerName in emitAssertion:
            headerNameNoHeaderStack = emitAssertion.replace("[", "").replace("]", "")
            returnString += "emit_header_" + headerNameNoHeaderStack + " = " + emitAssertion + ".isValid;\n\t"

    global emitPosition
    for header in headers:
        if header[0] == getHeaderType(headerName):
            for field in header[1]:
                size = typedef[field.type.path.name].type.size if field.type.Node_Type == "Type_Name" else field.type.size
                if hdrName.split(".")[1] in headerStackSize.keys():
                    for idx in range(headerStackSize[hdrName.split(".")[1]]):
                        # global emitPosition
                        emitPosition += size
                else:
                    # global emitPosition
                    emitPosition += size
    return returnString

def extract(node):
    returnString = ""
    headerToExtract = toJava(node.arguments.vec[0])
    returnString += "//Extract " + headerToExtract + "\n\t"
    returnString += "pos += " + headerToExtract + ".getBitLength();\n\t"
    if headerToExtract.endswith(".next"): # parsing a header stack
        headerToExtract = headerToExtract[:-5]
        returnString += headerToExtract + "[" + headerToExtract + "_index]" + ".isValid = true;\n\t"
        returnString += headerToExtract + "_index++;"
    else:
        returnString += headerToExtract + ".isValid = true;\n\t"
        returnString += "[POST]extract_header_" + headerToExtract.replace(".", "_") + " = 1;"
    return returnString

def advance(node):
    headerToAdvance = toJava(node.arguments.vec[0])
    return "//advance: " + toJava(node.method) + "\n\tpos += " + str(headerToAdvance) +";"

def cast(expr, toType):
    returnString = ""
    if toType.Node_Type == "Type_Bits":
        returnString += "(BitVariable) "
    return returnString + toJava(expr)

def klee_make_symbolic(var):
    funcName = "klee_make_symbolic"

    returnString = ""
    if "." in var:
        symbolic_name = "t" + str(uuid.uuid4()).replace("-", "_")
        returnString += "\n\tuint64_t "+ symbolic_name + ";\n"
        returnString += "\t" + funcName + "(&" + symbolic_name + ", sizeof(" + symbolic_name + "), \"" + symbolic_name + "\");\n\t"
        returnString += var + " = " + symbolic_name + ";\n"
    else:
        returnString += "\t" + funcName + "(&" + var + ", sizeof(" + var + "), \"" + var + "\");\n"
    return returnString

def define_instance(var, var_type):
    return "\t" + var + " = new " + var_type + "();\n"

# ---- V1 specific ----

def mark_to_drop():
    return "void mark_to_drop() {\n\t" + dropPacketCode() + "\n}\n"


